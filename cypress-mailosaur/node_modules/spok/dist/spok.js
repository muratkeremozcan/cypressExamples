"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ansicolors_1 = __importDefault(require("ansicolors"));
const inspect_1 = __importDefault(require("./inspect"));
const spok_assertions_1 = __importDefault(require("./spok-assertions"));
__exportStar(require("./types"), exports);
const adapter_chai_expect_1 = require("./adapter-chai-expect");
// only recurse into arrays if they contain actual specs or objects
function needRecurseArray(arr) {
    for (const el of arr) {
        if (typeof el !== 'number' && typeof el !== 'string' && el != null) {
            return true;
        }
    }
    return false;
}
function needRecurse(spec) {
    if (Array.isArray(spec))
        return needRecurseArray(spec);
    if (spec == null)
        return false;
    const keys = Object.keys(spec);
    if (keys.length === 0)
        return false;
    // if no spok functions are part of the spec, we could use deepEqual, but
    // we get a more fine grained output if we recurse even if the spec values
    // are constants
    return true;
}
/**
 * Checks the given specifications against the object.
 *
 * When the tests are run the **actual** values are printed
 * to verify visually while each provided specification is validated
 * and a test failure caused if one of them fails.
 *
 * @function
 *
 * @param {Object} t which has assertion functions `equal` and
 * `deepEqual` (to compare objects) - use * **tap**, **tape**,
 * **assert** or any other library that has those and thus is compatible
 *
 * @param {Object} obj the object to verify the specifications against
 * @param {Specifications} specifications the specifications to verify
 * @param {String } prefix added to messages
 */
const spokFunction = (t, obj, specifications, prefix = '') => {
    function check(k) {
        if (k === '$topic' || k === '$spec' || k === '$description')
            return;
        // @ts-ignore
        const spec = specifications[k];
        if (obj == null) {
            let summary = `property "${k}" checked on null or undefined`;
            let description = ', this is most likely due to an array in' +
                ' the specs that has more items than the actual array';
            if (spok.color) {
                summary = ansicolors_1.default.red(summary);
                description = ansicolors_1.default.brightBlack(description);
            }
            return t.equal(spec, obj, `${summary}${description}`);
        }
        // @ts-ignore
        const val = obj[k];
        let msg = prefix + k + ' = ' + (0, inspect_1.default)(val, spok.color);
        if (spec != null) {
            if (spec.$spec == null && spec.name != null && spec.name.length > 0) {
                spec.$spec = spec.name;
            }
            const ps = spok.printSpec && spec.$spec != null;
            const pd = spok.printDescription && spec.$description != null;
            if (ps)
                msg += '  ' + ansicolors_1.default.brightBlack('satisfies: ' + spec.$spec);
            if (pd)
                msg += '  ' + ansicolors_1.default.brightBlack(spec.$description);
        }
        switch (typeof spec) {
            case 'function':
                return t.equal(!!spec(val), true, msg);
            case 'boolean':
            case 'number':
            case 'string':
                return t.equal(val, spec, msg);
            case 'object':
                if (spec == null)
                    return t.equal(val, spec, msg);
                if (!needRecurse(spec))
                    return t.deepEqual(val, spec, msg);
                if (spec.$topic == null) {
                    const rootTopic = specifications.$topic != null ? specifications.$topic + '.' : '';
                    spec.$topic = rootTopic + k;
                }
                return spok(t, val, spec, prefix);
            default:
                throw new Error('at key "' +
                    k +
                    '" Type ' +
                    typeof spec +
                    ' not yet handled. Please submit a PR');
        }
    }
    if (specifications.$topic != null) {
        // print indicator that a specific spec started being evaluated
        t.equal(1, 1, prefix + 'spok: ' + specifications.$topic);
        prefix = prefix + '·· ';
    }
    // check all specs
    Object.keys(specifications).forEach(check);
    // provide confirmation that spec is done
    if (spok.sound) {
        require('child_process').execSync('say spokie dokie -v Vicki -r 600');
    }
};
/**
 * Version of `spok` that is less strict about the relation of the
 * specification type, namely it allows overriding the type manually or
 * derives it from the supplied parameter.
 *
 * Use ONLY when you cannot adjust the types, so plain `spok` works.
 *
 */
const spokFunctionAny = (t, obj, specifications, prefix = '') => {
    return spokFunction(t, obj, specifications, prefix);
};
const spokConfig = {
    printSpec: true,
    printDescription: false,
    sound: false,
    color: true,
};
const spok = Object.assign(spokFunction, { any: spokFunctionAny }, spok_assertions_1.default, spokConfig, { adapters: { chaiExpect: adapter_chai_expect_1.chaiExpect } });
exports.default = spok;
//# sourceMappingURL=spok.js.map